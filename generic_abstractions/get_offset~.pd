#N canvas 209 224 763 637 10;
#X obj 32 347 iemguts/oreceive;
#X text 29 224 this sets the real inlet number without the offset imposed
by [module_data];
#X msg 32 324 symbol receive_offset\$1;
#X obj 32 449 t s s;
#X obj 32 515 outlet~;
#X obj 32 302 + \$2;
#X obj 32 257 r module_data\$1;
#X obj 32 279 unpack;
#X obj 32 369 route symbol bang;
#X obj 90 391 \$0;
#X msg 90 413 symbol \$1-no_offset;
#X obj 314 387 s;
#X obj 314 341 inlet;
#X obj 354 341 inlet;
#X msg 32 471 set \$1;
#X obj 33 576 s~ \$0-no_offset;
#X obj 32 493 r~ \$0-no_offset;
#X obj 314 365 pack f \$3 \$4;
#X text 30 19 this abstraction works with the offset module. it receives
input when a signal passes through that module. the signal received
in [r~] comes from the offset module and it's used to give an offset
to the signal that passes through the offset module. when there's no
signal coming here through the offset module \, [r~] listens to [s~
\$0-no_offset] and gives zero offset. its arguments are the module
index \, the inlet number (the inlet that receives the signal to be
offset by [r~] in here) of this module \, starting from 0 \, the maximum
range of the potentiometer received in the (sub)patch containing this
abstraction \, and the power to raise the offsetting potentiometer
to (in case the range needs to be logarithmic);
#X text 312 287 send the max value of the scaling range and the actual
value of the potentiometer to the offset module so that its range will
be the remaining range of the scaling potentiometer;
#X obj 33 552 sig~ 0;
#X connect 0 0 8 0;
#X connect 2 0 0 0;
#X connect 3 0 14 0;
#X connect 3 1 11 1;
#X connect 5 0 2 0;
#X connect 6 0 7 0;
#X connect 7 0 5 0;
#X connect 8 0 3 0;
#X connect 8 1 9 0;
#X connect 9 0 10 0;
#X connect 10 0 3 0;
#X connect 12 0 17 0;
#X connect 13 0 17 1;
#X connect 14 0 16 0;
#X connect 16 0 4 0;
#X connect 17 0 11 0;
#X connect 20 0 15 0;
