#N canvas 33 82 1541 951 10;
#X declare -path ../generic_abstractions;
#X obj 44 28 cnv 15 420 90 empty empty Declare_generic_abstractions_path
0 -12 0 14 -204786 -66577 0;
#X obj 52 94 declare -path ../generic_abstractions;
#X obj 49 296 r module\$1;
#X obj 123 789 r analog_res;
#X obj 170 642 r analog_res;
#X obj 484 28 cnv 15 490 90 empty empty Use_module_data_and_switch~
0 -12 0 14 -204786 -66577 0;
#X obj 497 69 module_data \$0 \$1 \$2 \$3;
#X obj 497 92 switch~;
#X text 493 34 [module_data \$0 \$1 \$2 \$3] must be used in all module
abstractions \, otherwise the whole system will not work;
#X text 555 93 <- control the DSP of the module accodring to its activity
;
#X obj 804 341 module_output~ 0;
#X obj 119 665 map_zero 1023 1;
#X obj 49 318 route 0 1;
#X obj 147 715 r analog_res;
#X obj 96 738 map_zero 1023 1;
#X text 50 34 you must declare the path to the generic abstractions
as they are used in all module abstractions ([get_switches] \, [assemble_analog_inputs]
\, [map] \, map_zero] \, and [module_data].;
#X text 44 181 evrey module receives potentiometer and switch data
with [r module\$1] \, where \$1 is the module index in the chain \,
starting from 1;
#X text 44 229 a leading 0 in the data received in [r module\$1] denotes
potentiomere data \, while a leading 1 denotes switch data;
#X text 128 318 <- split data according to potentiometer and switch
data index;
#X text 193 349 <- get your switch data. argument is number of switches
;
#X text 234 499 <- get your potentiometer values. argument is number
of potentiometers;
#X text 130 295 <- get your potentiometer and switch data here;
#X text 219 789 <- the resolution of the analog pins is sent from the
Arduino and received in [pd init] \, in [pd moduels]. from there it
is sent to [r analog_res]. [map_zero] sets a default 10-bit resolution
since it's the standard resolution of the Arduino \, and [r analog_res]
changes it to the resolution used \, in case it's different than 10-bit
(like with the Teensy3.2 \, which is 13-bit);
#X text 236 665 <- [map_zero] maps a range starting from 0 to the value
of the first argument to a range from 0 to the second argument;
#X text 802 365 the [module_output~] abstractions forward their incoming
signals to the matrix of the synthesizer. they are necessary in order
for each module to be connected to the rest of the system. their argument
is the output number starting from zero.;
#X obj 174 375 change;
#X obj 79 375 change;
#X text 223 371 [get_switches] outputs all values even when only one
switch changes \, that's why we use [change] here;
#N canvas 535 248 1064 561 calculate_ADSR 0;
#X obj 57 432 +;
#X obj 382 365 swap 1;
#X obj 382 387 -;
#X obj 357 432 swap;
#X obj 357 454 /;
#X obj 357 476 * -1;
#X obj 720 359 swap 1;
#X obj 720 381 -;
#X obj 382 342 t f f;
#X obj 505 359 /;
#X obj 505 381 * -1;
#X obj 57 454 s \$0-AD_sum;
#X obj 357 498 s \$0-D_scale;
#X obj 505 403 s \$0-R_scale;
#X obj 720 403 s \$0-R_inverse;
#X obj 57 326 t f f;
#X obj 89 347 s \$0-A_norm;
#X obj 382 299 t f f;
#X obj 414 320 s \$0-S_norm;
#X obj 204 415 t f f f;
#X obj 227 437 pow -1;
#X obj 227 459 * -1;
#X obj 227 481 s \$0-D_normalize;
#X obj 382 409 t f f;
#X obj 414 432 s \$0-D_curve_scale;
#X obj 593 342 t f f f;
#X obj 616 385 pow -1;
#X obj 616 407 * -1;
#X obj 616 429 s \$0-R_normalize;
#X obj 870 299 t f f;
#X obj 902 368 s \$0-exp_curve;
#X obj 870 394 * -0.5;
#X obj 870 416 + 1;
#X obj 870 438 s \$0-log_curve;
#X obj 902 322 * 3;
#X obj 902 344 + 1;
#X obj 57 276 r \$0-attack;
#X obj 204 276 r \$0-decay;
#X obj 382 276 r \$0-sustain;
#X obj 593 276 r \$0-release;
#X obj 870 276 r \$0-curvature;
#X connect 0 0 11 0;
#X connect 1 0 2 0;
#X connect 1 1 2 1;
#X connect 2 0 23 0;
#X connect 3 0 4 0;
#X connect 3 1 4 1;
#X connect 4 0 5 0;
#X connect 5 0 12 0;
#X connect 6 0 7 0;
#X connect 6 1 7 1;
#X connect 7 0 14 0;
#X connect 8 0 1 0;
#X connect 8 1 9 0;
#X connect 9 0 10 0;
#X connect 10 0 13 0;
#X connect 15 0 0 0;
#X connect 15 1 16 0;
#X connect 17 0 8 0;
#X connect 17 1 18 0;
#X connect 19 0 0 1;
#X connect 19 1 20 0;
#X connect 19 2 3 0;
#X connect 20 0 21 0;
#X connect 21 0 22 0;
#X connect 23 0 3 1;
#X connect 23 1 24 0;
#X connect 25 0 9 1;
#X connect 25 1 26 0;
#X connect 25 2 6 0;
#X connect 26 0 27 0;
#X connect 27 0 28 0;
#X connect 29 0 31 0;
#X connect 29 1 34 0;
#X connect 31 0 32 0;
#X connect 32 0 33 0;
#X connect 34 0 35 0;
#X connect 35 0 30 0;
#X connect 36 0 15 0;
#X connect 37 0 19 0;
#X connect 38 0 17 0;
#X connect 39 0 25 0;
#X connect 40 0 29 0;
#X restore 1347 159 pd calculate_ADSR;
#N canvas 686 82 958 717 ADSR_envelope 0;
#X obj 28 368 /;
#X obj 245 300 r \$0-D_normalize;
#X obj 210 295 -;
#X obj 210 317 *;
#X obj 228 406 r \$0-D_curve_scale;
#X obj 210 428 *;
#X obj 210 459 +;
#X obj 322 463 &&;
#X obj 469 394 &&;
#X obj 487 332 r \$0-AD_sum;
#X obj 637 279 r \$0-R_inverse;
#X obj 580 353 -;
#X obj 580 375 *;
#X obj 652 358 r \$0-R_normalize;
#X obj 580 442 *;
#X obj 494 83 t f b;
#X obj 494 105 until;
#X obj 494 149 f;
#X obj 524 149 + 1;
#X msg 512 126 0;
#X obj 210 480 spigot;
#X obj 28 418 spigot;
#X obj 398 411 spigot;
#X obj 580 464 spigot;
#X obj 46 233 r \$0-A_norm;
#X obj 517 219 t f f f f f f f;
#X obj 416 311 r \$0-S_norm;
#X obj 398 387 f;
#X obj 28 160 t f f b f;
#X obj 92 401 <=;
#X obj 322 427 >;
#X obj 354 446 <=;
#X obj 469 373 >;
#X obj 515 377 <=;
#X obj 619 313 >;
#X obj 210 339 + 1;
#X obj 580 397 + 1;
#X obj 60 368 r \$0-log_curve;
#X obj 260 344 r \$0-exp_curve;
#X obj 633 402 r \$0-exp_curve;
#X obj 494 15 r \$0-make_env;
#X obj 494 37 t b b;
#X obj 619 335 t f f;
#X text 29 93 zero last index;
#X msg 494 61 2048;
#X msg 31 52 2047 0;
#X obj 31 30 sel 2047;
#X obj 325 631 array define \$0-envelope 2048;
#X obj 325 604 tabwrite \$0-envelope;
#X obj 31 74 s \$0-envelope;
#X obj 28 392 pow 1;
#X obj 210 361 pow 1;
#X obj 580 419 pow 1;
#X obj 517 196 / 2047;
#X obj 494 171 t f f f;
#X connect 0 0 50 0;
#X connect 1 0 3 1;
#X connect 2 0 3 0;
#X connect 3 0 35 0;
#X connect 4 0 5 1;
#X connect 5 0 6 0;
#X connect 6 0 20 0;
#X connect 7 0 20 1;
#X connect 8 0 22 1;
#X connect 9 0 31 1;
#X connect 9 0 32 1;
#X connect 10 0 11 1;
#X connect 10 0 33 1;
#X connect 10 0 34 1;
#X connect 11 0 12 0;
#X connect 12 0 36 0;
#X connect 13 0 12 1;
#X connect 14 0 23 0;
#X connect 15 0 16 0;
#X connect 15 1 19 0;
#X connect 16 0 17 0;
#X connect 17 0 18 0;
#X connect 17 0 54 0;
#X connect 18 0 17 1;
#X connect 19 0 17 1;
#X connect 20 0 48 0;
#X connect 21 0 48 0;
#X connect 22 0 48 0;
#X connect 23 0 48 0;
#X connect 24 0 0 1;
#X connect 24 0 2 1;
#X connect 24 0 29 1;
#X connect 24 0 30 1;
#X connect 25 0 28 0;
#X connect 25 1 29 0;
#X connect 25 2 30 0;
#X connect 25 3 31 0;
#X connect 25 4 32 0;
#X connect 25 5 33 0;
#X connect 25 6 34 0;
#X connect 26 0 6 1;
#X connect 26 0 14 1;
#X connect 26 0 27 1;
#X connect 27 0 22 0;
#X connect 28 0 0 0;
#X connect 28 1 2 0;
#X connect 28 2 27 0;
#X connect 28 3 11 0;
#X connect 29 0 21 1;
#X connect 30 0 7 0;
#X connect 31 0 7 1;
#X connect 32 0 8 0;
#X connect 33 0 8 1;
#X connect 34 0 42 0;
#X connect 35 0 51 0;
#X connect 36 0 52 0;
#X connect 37 0 50 1;
#X connect 38 0 51 1;
#X connect 39 0 52 1;
#X connect 40 0 41 0;
#X connect 41 0 44 0;
#X connect 42 0 23 1;
#X connect 44 0 15 0;
#X connect 45 0 49 0;
#X connect 46 0 45 0;
#X connect 50 0 21 0;
#X connect 51 0 5 0;
#X connect 52 0 14 0;
#X connect 53 0 25 0;
#X connect 54 0 46 0;
#X connect 54 1 53 0;
#X connect 54 2 48 1;
#X restore 1347 186 pd ADSR_envelope;
#X obj 100 860 r analog_res;
#X obj 49 882 map_zero 1023 1;
#X obj 72 812 map_zero 1023 1;
#X obj 49 904 s \$0-attack;
#X obj 72 834 s \$0-decay;
#X obj 96 760 s \$0-sustain;
#X obj 119 687 s \$0-release;
#X obj 49 501 assemble_analog_inputs 8;
#X obj 204 573 r analog_res;
#X obj 143 618 s \$0-env_dur0;
#X obj 283 618 s \$0-env_dur1;
#X obj 423 618 s \$0-env_dur2;
#X obj 563 618 s \$0-env_dur3;
#X obj 79 403 sel 1;
#X obj 79 427 s \$0-make_env;
#X obj 174 403 s \$0-curvature;
#X obj 143 596 map_zero 1023 2047;
#X obj 344 573 r analog_res;
#X obj 283 596 map_zero 1023 2047;
#X obj 484 573 r analog_res;
#X obj 423 596 map_zero 1023 2047;
#X obj 624 573 r analog_res;
#X obj 563 596 map_zero 1023 2047;
#N canvas 1 82 591 399 trigger-envelope0 0;
#X obj 21 99 threshold~ 1e-06 10 1e-06 10;
#N canvas 1 82 450 300 debounce 0;
#X obj 76 64 inlet;
#X obj 76 86 spigot 1;
#X obj 76 108 t b b b;
#X msg 129 64 0;
#X obj 173 125 del 100;
#X msg 173 147 1;
#X obj 76 195 outlet;
#X connect 0 0 1 0;
#X connect 1 0 2 0;
#X connect 2 0 6 0;
#X connect 2 1 3 0;
#X connect 2 2 4 0;
#X connect 3 0 1 1;
#X connect 4 0 5 0;
#X connect 5 0 1 1;
#X restore 21 134 pd debounce;
#X obj 21 27 inlet~;
#X obj 21 275 line~;
#X obj 21 320 outlet~;
#X obj 21 226 f;
#X text 172 296 use [tabread~] instead of [tabread4~] because with
the latter the envelope value is never zeroed;
#X msg 21 249 0 \, 2047 \$1;
#X obj 21 297 tabread~ \$0-envelope;
#X obj 39 203 r \$0-env_dur0;
#X text 32 59 use a very low value for the threshold so you can trigger
the envelope both with bipolar and unipolar signals;
#X connect 0 0 1 0;
#X connect 1 0 5 0;
#X connect 2 0 0 0;
#X connect 3 0 8 0;
#X connect 5 0 7 0;
#X connect 7 0 3 0;
#X connect 8 0 4 0;
#X connect 9 0 5 1;
#X restore 804 316 pd trigger-envelope0;
#X obj 804 292 module_input~ 0;
#X obj 964 292 module_input~ 1;
#N canvas 1 82 617 505 trigger-envelope1 0;
#X obj 21 139 threshold~ 1e-06 10 1e-06 10;
#N canvas 1 82 450 300 debounce 0;
#X obj 76 64 inlet;
#X obj 76 86 spigot 1;
#X obj 76 108 t b b b;
#X msg 129 64 0;
#X obj 173 125 del 100;
#X msg 173 147 1;
#X obj 76 195 outlet;
#X connect 0 0 1 0;
#X connect 1 0 2 0;
#X connect 2 0 6 0;
#X connect 2 1 3 0;
#X connect 2 2 4 0;
#X connect 3 0 1 1;
#X connect 4 0 5 0;
#X connect 5 0 1 1;
#X restore 21 164 pd debounce;
#X obj 21 37 inlet~;
#X obj 21 305 line~;
#X obj 21 350 outlet~;
#X obj 21 256 f;
#X text 172 326 use [tabread~] instead of [tabread4~] because with
the latter the envelope value is never zeroed;
#X msg 21 279 0 \, 2047 \$1;
#X obj 21 327 tabread~ \$0-envelope;
#X obj 39 233 r \$0-env_dur1;
#X text 32 89 use a very low value for the threshold so you can trigger
the envelope both with bipolar and unipolar signals;
#X connect 0 0 1 0;
#X connect 1 0 5 0;
#X connect 2 0 0 0;
#X connect 3 0 8 0;
#X connect 5 0 7 0;
#X connect 7 0 3 0;
#X connect 8 0 4 0;
#X connect 9 0 5 1;
#X restore 964 316 pd trigger-envelope1;
#X obj 964 341 module_output~ 1;
#X obj 1124 292 module_input~ 2;
#N canvas 1 82 617 505 trigger-envelope2 0;
#X obj 21 149 threshold~ 1e-06 10 1e-06 10;
#N canvas 1 82 450 300 debounce 0;
#X obj 76 64 inlet;
#X obj 76 86 spigot 1;
#X obj 76 108 t b b b;
#X msg 129 64 0;
#X obj 173 125 del 100;
#X msg 173 147 1;
#X obj 76 195 outlet;
#X connect 0 0 1 0;
#X connect 1 0 2 0;
#X connect 2 0 6 0;
#X connect 2 1 3 0;
#X connect 2 2 4 0;
#X connect 3 0 1 1;
#X connect 4 0 5 0;
#X connect 5 0 1 1;
#X restore 21 174 pd debounce;
#X obj 21 47 inlet~;
#X obj 21 315 line~;
#X obj 21 360 outlet~;
#X obj 21 266 f;
#X text 172 336 use [tabread~] instead of [tabread4~] because with
the latter the envelope value is never zeroed;
#X msg 21 289 0 \, 2047 \$1;
#X obj 21 337 tabread~ \$0-envelope;
#X obj 39 243 r \$0-env_dur2;
#X text 32 109 use a very low value for the threshold so you can trigger
the envelope both with bipolar and unipolar signals;
#X connect 0 0 1 0;
#X connect 1 0 5 0;
#X connect 2 0 0 0;
#X connect 3 0 8 0;
#X connect 5 0 7 0;
#X connect 7 0 3 0;
#X connect 8 0 4 0;
#X connect 9 0 5 1;
#X restore 1124 316 pd trigger-envelope2;
#X obj 1124 341 module_output~ 2;
#X obj 1284 292 module_input~ 3;
#N canvas 1 82 617 505 trigger-envelope3 0;
#X obj 21 149 threshold~ 1e-06 10 1e-06 10;
#N canvas 1 82 450 300 debounce 0;
#X obj 76 64 inlet;
#X obj 76 86 spigot 1;
#X obj 76 108 t b b b;
#X msg 129 64 0;
#X obj 173 125 del 100;
#X msg 173 147 1;
#X obj 76 195 outlet;
#X connect 0 0 1 0;
#X connect 1 0 2 0;
#X connect 2 0 6 0;
#X connect 2 1 3 0;
#X connect 2 2 4 0;
#X connect 3 0 1 1;
#X connect 4 0 5 0;
#X connect 5 0 1 1;
#X restore 21 174 pd debounce;
#X obj 21 47 inlet~;
#X obj 21 315 line~;
#X obj 21 360 outlet~;
#X obj 21 266 f;
#X text 172 336 use [tabread~] instead of [tabread4~] because with
the latter the envelope value is never zeroed;
#X msg 21 289 0 \, 2047 \$1;
#X obj 21 337 tabread~ \$0-envelope;
#X obj 39 243 r \$0-env_dur3;
#X text 32 109 use a very low value for the threshold so you can trigger
the envelope both with bipolar and unipolar signals;
#X connect 0 0 1 0;
#X connect 1 0 5 0;
#X connect 2 0 0 0;
#X connect 3 0 8 0;
#X connect 5 0 7 0;
#X connect 7 0 3 0;
#X connect 8 0 4 0;
#X connect 9 0 5 1;
#X restore 1284 316 pd trigger-envelope3;
#X obj 1284 341 module_output~ 3;
#X obj 79 350 get_switches 2;
#X text 45 143 this module is a simple envelope generator with four
outputs that can be controlled by four CVs;
#X text 801 262 check the [pd trigger-envelope] subpatches below;
#X text 800 142 the function of this module happens below \, where
we receive the scaled potentiometer values and the input signals. after
all the processing \, we send the resulting signals to the [module_output~]
abstractions which send their outputs to the matrix of the synthesizer.
The signal inputs of this module (coming from the matrix) are received
through the [module_input~] abstraction which takes the input number
(starting from 0) as its argument;
#X text 77 446 the first switch here is a push-button used to generate
the envelope according to the values of the first four potentiometers
;
#X connect 2 0 12 0;
#X connect 3 0 32 1;
#X connect 4 0 11 1;
#X connect 6 0 7 0;
#X connect 11 0 36 0;
#X connect 12 0 37 0;
#X connect 12 1 64 0;
#X connect 13 0 14 1;
#X connect 14 0 35 0;
#X connect 25 0 45 0;
#X connect 26 0 43 0;
#X connect 30 0 31 1;
#X connect 31 0 33 0;
#X connect 32 0 34 0;
#X connect 37 0 31 0;
#X connect 37 1 32 0;
#X connect 37 2 14 0;
#X connect 37 3 11 0;
#X connect 37 4 46 0;
#X connect 37 5 48 0;
#X connect 37 6 50 0;
#X connect 37 7 52 0;
#X connect 38 0 46 1;
#X connect 43 0 44 0;
#X connect 46 0 39 0;
#X connect 47 0 48 1;
#X connect 48 0 40 0;
#X connect 49 0 50 1;
#X connect 50 0 41 0;
#X connect 51 0 52 1;
#X connect 52 0 42 0;
#X connect 53 0 10 0;
#X connect 54 0 53 0;
#X connect 55 0 56 0;
#X connect 56 0 57 0;
#X connect 58 0 59 0;
#X connect 59 0 60 0;
#X connect 61 0 62 0;
#X connect 62 0 63 0;
#X connect 64 0 26 0;
#X connect 64 1 25 0;
