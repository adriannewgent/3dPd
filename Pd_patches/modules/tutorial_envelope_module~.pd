#N canvas 285 82 1421 533 10;
#X declare -path ../generic_abstractions -path ./module_abstractions
;
#X obj 44 28 cnv 15 430 100 empty empty Declare_generic_abstractions_path
0 -12 0 14 -204786 -66577 0;
#X obj 484 28 cnv 15 490 100 empty empty Use_module_data_and_switch~
0 -12 0 14 -204786 -66577 0;
#X obj 497 69 module_data \$0 \$1 \$2 \$3;
#X obj 497 92 switch~;
#X text 493 34 [module_data \$0 \$1 \$2 \$3] must be used in all module
abstractions \, otherwise the whole system will not work;
#X text 555 93 <- control the DSP of the module accodring to its activity
;
#X obj 491 401 module_output~ 0;
#X text 486 147 the function of this module happens below \, where
we receive the scaled potentiometer values and the input signals. after
all the processing \, we send the resulting signals to the [module_output~]
abstractions which send their outputs to the matrix of the synthesizer.
;
#X text 489 425 the [module_output~] abstractions forward their incoming
signals to the matrix of the synthesizer. they are necessary in order
for each module to be connected to the rest of the system. their argument
is the output number starting from zero.;
#N canvas 535 248 1049 357 calculate_ADSR 0;
#X obj 57 202 +;
#X obj 382 135 swap 1;
#X obj 382 157 -;
#X obj 357 202 swap;
#X obj 357 224 /;
#X obj 357 246 * -1;
#X obj 720 129 swap 1;
#X obj 720 151 -;
#X obj 382 112 t f f;
#X obj 505 129 /;
#X obj 505 151 * -1;
#X obj 57 224 s \$0-AD_sum;
#X obj 357 268 s \$0-D_scale;
#X obj 505 173 s \$0-R_scale;
#X obj 720 173 s \$0-R_inverse;
#X obj 57 96 t f f;
#X obj 89 117 s \$0-A_norm;
#X obj 382 69 t f f;
#X obj 414 90 s \$0-S_norm;
#X obj 204 185 t f f f;
#X obj 227 207 pow -1;
#X obj 227 229 * -1;
#X obj 227 251 s \$0-D_normalize;
#X obj 382 179 t f f;
#X obj 414 202 s \$0-D_curve_scale;
#X obj 593 112 t f f f;
#X obj 616 155 pow -1;
#X obj 616 177 * -1;
#X obj 616 199 s \$0-R_normalize;
#X obj 870 69 t f f;
#X obj 902 138 s \$0-exp_curve;
#X obj 870 164 * -0.5;
#X obj 870 186 + 1;
#X obj 870 208 s \$0-log_curve;
#X obj 902 92 * 3;
#X obj 902 114 + 1;
#X obj 57 46 r \$0-attack;
#X obj 204 46 r \$0-decay;
#X obj 382 46 r \$0-sustain;
#X obj 593 46 r \$0-release;
#X obj 870 46 r \$0-curvature;
#X connect 0 0 11 0;
#X connect 1 0 2 0;
#X connect 1 1 2 1;
#X connect 2 0 23 0;
#X connect 3 0 4 0;
#X connect 3 1 4 1;
#X connect 4 0 5 0;
#X connect 5 0 12 0;
#X connect 6 0 7 0;
#X connect 6 1 7 1;
#X connect 7 0 14 0;
#X connect 8 0 1 0;
#X connect 8 1 9 0;
#X connect 9 0 10 0;
#X connect 10 0 13 0;
#X connect 15 0 0 0;
#X connect 15 1 16 0;
#X connect 17 0 8 0;
#X connect 17 1 18 0;
#X connect 19 0 0 1;
#X connect 19 1 20 0;
#X connect 19 2 3 0;
#X connect 20 0 21 0;
#X connect 21 0 22 0;
#X connect 23 0 3 1;
#X connect 23 1 24 0;
#X connect 25 0 9 1;
#X connect 25 1 26 0;
#X connect 25 2 6 0;
#X connect 26 0 27 0;
#X connect 27 0 28 0;
#X connect 29 0 31 0;
#X connect 29 1 34 0;
#X connect 31 0 32 0;
#X connect 32 0 33 0;
#X connect 34 0 35 0;
#X connect 35 0 30 0;
#X connect 36 0 15 0;
#X connect 37 0 19 0;
#X connect 38 0 17 0;
#X connect 39 0 25 0;
#X connect 40 0 29 0;
#X restore 50 312 pd calculate_ADSR;
#N canvas 686 82 958 717 ADSR_envelope 0;
#X obj 28 368 /;
#X obj 245 300 r \$0-D_normalize;
#X obj 210 295 -;
#X obj 210 317 *;
#X obj 228 406 r \$0-D_curve_scale;
#X obj 210 428 *;
#X obj 210 459 +;
#X obj 322 463 &&;
#X obj 469 394 &&;
#X obj 487 332 r \$0-AD_sum;
#X obj 637 279 r \$0-R_inverse;
#X obj 580 353 -;
#X obj 580 375 *;
#X obj 652 358 r \$0-R_normalize;
#X obj 580 442 *;
#X obj 494 83 t f b;
#X obj 494 105 until;
#X obj 494 149 f;
#X obj 524 149 + 1;
#X msg 512 126 0;
#X obj 210 480 spigot;
#X obj 28 418 spigot;
#X obj 398 411 spigot;
#X obj 580 464 spigot;
#X obj 46 233 r \$0-A_norm;
#X obj 517 219 t f f f f f f f;
#X obj 416 311 r \$0-S_norm;
#X obj 398 387 f;
#X obj 28 160 t f f b f;
#X obj 92 401 <=;
#X obj 322 427 >;
#X obj 354 446 <=;
#X obj 469 373 >;
#X obj 515 377 <=;
#X obj 619 313 >;
#X obj 210 339 + 1;
#X obj 580 397 + 1;
#X obj 60 368 r \$0-log_curve;
#X obj 260 344 r \$0-exp_curve;
#X obj 633 402 r \$0-exp_curve;
#X obj 494 15 r \$0-make_env;
#X obj 494 37 t b b;
#X obj 619 335 t f f;
#X text 29 93 zero last index;
#X msg 494 61 2048;
#X msg 31 52 2047 0;
#X obj 31 30 sel 2047;
#X obj 325 631 array define \$0-envelope 2048;
#X obj 325 604 tabwrite \$0-envelope;
#X obj 31 74 s \$0-envelope;
#X obj 28 392 pow 1;
#X obj 210 361 pow 1;
#X obj 580 419 pow 1;
#X obj 517 196 / 2047;
#X obj 494 171 t f f f;
#X connect 0 0 50 0;
#X connect 1 0 3 1;
#X connect 2 0 3 0;
#X connect 3 0 35 0;
#X connect 4 0 5 1;
#X connect 5 0 6 0;
#X connect 6 0 20 0;
#X connect 7 0 20 1;
#X connect 8 0 22 1;
#X connect 9 0 31 1;
#X connect 9 0 32 1;
#X connect 10 0 11 1;
#X connect 10 0 33 1;
#X connect 10 0 34 1;
#X connect 11 0 12 0;
#X connect 12 0 36 0;
#X connect 13 0 12 1;
#X connect 14 0 23 0;
#X connect 15 0 16 0;
#X connect 15 1 19 0;
#X connect 16 0 17 0;
#X connect 17 0 18 0;
#X connect 17 0 54 0;
#X connect 18 0 17 1;
#X connect 19 0 17 1;
#X connect 20 0 48 0;
#X connect 21 0 48 0;
#X connect 22 0 48 0;
#X connect 23 0 48 0;
#X connect 24 0 0 1;
#X connect 24 0 2 1;
#X connect 24 0 29 1;
#X connect 24 0 30 1;
#X connect 25 0 28 0;
#X connect 25 1 29 0;
#X connect 25 2 30 0;
#X connect 25 3 31 0;
#X connect 25 4 32 0;
#X connect 25 5 33 0;
#X connect 25 6 34 0;
#X connect 26 0 6 1;
#X connect 26 0 14 1;
#X connect 26 0 27 1;
#X connect 27 0 22 0;
#X connect 28 0 0 0;
#X connect 28 1 2 0;
#X connect 28 2 27 0;
#X connect 28 3 11 0;
#X connect 29 0 21 1;
#X connect 30 0 7 0;
#X connect 31 0 7 1;
#X connect 32 0 8 0;
#X connect 33 0 8 1;
#X connect 34 0 42 0;
#X connect 35 0 51 0;
#X connect 36 0 52 0;
#X connect 37 0 50 1;
#X connect 38 0 51 1;
#X connect 39 0 52 1;
#X connect 40 0 41 0;
#X connect 41 0 44 0;
#X connect 42 0 23 1;
#X connect 44 0 15 0;
#X connect 45 0 49 0;
#X connect 46 0 45 0;
#X connect 50 0 21 0;
#X connect 51 0 5 0;
#X connect 52 0 14 0;
#X connect 53 0 25 0;
#X connect 54 0 46 0;
#X connect 54 1 53 0;
#X connect 54 2 48 1;
#X restore 50 339 pd ADSR_envelope;
#X obj 491 302 module_input~ 0;
#X obj 711 302 module_input~ 1;
#X obj 711 401 module_output~ 1;
#X obj 931 302 module_input~ 2;
#X obj 931 401 module_output~ 2;
#X obj 1151 302 module_input~ 3;
#X obj 1151 401 module_output~ 3;
#X text 45 143 this module is a simple envelope generator with four
outputs that can be controlled by four CVs;
#N canvas 228 169 763 727 pots_and_switches 0;
#X obj 19 116 r module\$1;
#X obj 91 569 r analog_res;
#X obj 134 422 r analog_res;
#X obj 83 445 map_zero 1023 1;
#X obj 113 495 r analog_res;
#X obj 62 518 map_zero 1023 1;
#X text 14 21 evrey module receives potentiometer and switch data with
[r module\$1] \, where \$1 is the module index in the chain \, starting
from 1;
#X text 100 115 <- get your potentiometer and switch data here;
#X text 200 445 <- [map_zero] maps a range starting from 0 to the value
of the first argument to a range from 0 to the second argument;
#X obj 151 195 change;
#X obj 84 195 change;
#X obj 70 640 r analog_res;
#X obj 19 662 map_zero 1023 1;
#X obj 40 592 map_zero 1023 1;
#X obj 19 684 s \$0-attack;
#X obj 40 614 s \$0-decay;
#X obj 62 540 s \$0-sustain;
#X obj 83 467 s \$0-release;
#X obj 166 353 r analog_res;
#X obj 105 398 s \$0-env_dur0;
#X obj 245 398 s \$0-env_dur1;
#X obj 385 398 s \$0-env_dur2;
#X obj 525 398 s \$0-env_dur3;
#X obj 84 223 sel 1;
#X obj 84 247 s \$0-make_env;
#X obj 151 223 s \$0-curvature;
#X obj 105 376 map_zero 1023 2047;
#X obj 306 353 r analog_res;
#X obj 245 376 map_zero 1023 2047;
#X obj 446 353 r analog_res;
#X obj 385 376 map_zero 1023 2047;
#X obj 586 353 r analog_res;
#X obj 525 376 map_zero 1023 2047;
#X text 187 569 <- the resolution of the analog pins is sent from the
Arduino and received in [pd init] \, in [pd moduels]. from there it
is sent to [r analog_res]. [map_zero] sets a default 10-bit resolution
(1st argument) since it's the standard resolution of the Arduino \,
and [r analog_res] changes it to the resolution used \, in case it's
different than 10-bit (like with the Teensy3.2 \, which is 13-bit)
;
#X obj 84 170 unpack f f;
#X obj 19 281 unpack f f f f f f f f;
#X obj 19 138 route pots switches;
#X obj 105 330 filter_pot 0.85;
#X obj 245 330 filter_pot 0.85;
#X obj 385 330 filter_pot 0.85;
#X obj 525 330 filter_pot 0.85;
#X text 253 292 filtering the first four pots is not really necessary
;
#X text 15 73 here we're using eight potentiometers \, one push-button
and one switch;
#X text 261 223 we can set whether the envelope will be linear or curved
;
#X connect 0 0 36 0;
#X connect 1 0 13 1;
#X connect 2 0 3 1;
#X connect 3 0 17 0;
#X connect 4 0 5 1;
#X connect 5 0 16 0;
#X connect 9 0 25 0;
#X connect 10 0 23 0;
#X connect 11 0 12 1;
#X connect 12 0 14 0;
#X connect 13 0 15 0;
#X connect 18 0 26 1;
#X connect 23 0 24 0;
#X connect 26 0 19 0;
#X connect 27 0 28 1;
#X connect 28 0 20 0;
#X connect 29 0 30 1;
#X connect 30 0 21 0;
#X connect 31 0 32 1;
#X connect 32 0 22 0;
#X connect 34 0 10 0;
#X connect 34 1 9 0;
#X connect 35 0 12 0;
#X connect 35 1 13 0;
#X connect 35 2 5 0;
#X connect 35 3 3 0;
#X connect 35 4 37 0;
#X connect 35 5 38 0;
#X connect 35 6 39 0;
#X connect 35 7 40 0;
#X connect 36 0 35 0;
#X connect 36 1 34 0;
#X connect 37 0 26 0;
#X connect 38 0 28 0;
#X connect 39 0 30 0;
#X connect 40 0 32 0;
#X restore 50 284 pd pots_and_switches;
#X text 49 261 check the subpatches below;
#X obj 642 349 led_ctl 4;
#X obj 862 349 led_ctl 5;
#X obj 1082 349 led_ctl 6;
#X obj 1302 349 led_ctl 7;
#X text 641 371 blink LEDs when the envelope is triggered;
#X text 47 192 set the ADSR values with the first four potentiometers
and create the envelope by pushing the push-button (it must be wired
to the first input after the banana terminals;
#X obj 52 94 declare -path ../generic_abstractions -path ./module_abstractions
;
#X obj 491 326 trigger_envelope~ \$0 0;
#X obj 711 326 trigger_envelope~ \$0 1;
#X obj 931 326 trigger_envelope~ \$0 2;
#X obj 1151 326 trigger_envelope~ \$0 3;
#X text 487 224 in this module we're using an extra abstraction \,
[trigger_envelope~] which is in the module_abstractions directory \,
which is set in this abstractions path via [declare];
#X text 50 34 you must declare the path to the generic abstractions
as they are used in all module abstractions (here we use [map] \, map_zero]
\, and [module_data]) \, as well as the module_abstractions directory.
;
#X connect 2 0 3 0;
#X connect 11 0 28 0;
#X connect 11 1 28 1;
#X connect 12 0 29 0;
#X connect 12 1 29 1;
#X connect 14 0 30 0;
#X connect 14 1 30 1;
#X connect 16 0 31 0;
#X connect 16 1 31 1;
#X connect 28 0 6 0;
#X connect 28 1 21 0;
#X connect 29 0 13 0;
#X connect 29 1 22 0;
#X connect 30 0 15 0;
#X connect 30 1 23 0;
#X connect 31 0 17 0;
#X connect 31 1 24 0;
