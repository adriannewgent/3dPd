#N canvas 41 82 1389 769 10;
#X declare -path ../generic_abstractions;
#X obj 44 28 cnv 15 420 90 empty empty Declare_generic_abstractions_path
0 -12 0 14 -204786 -66577 0;
#X obj 52 94 declare -path ../generic_abstractions;
#X obj 49 316 r module\$1;
#X obj 484 28 cnv 15 490 90 empty empty Use_module_data_and_switch~
0 -12 0 14 -204786 -66577 0;
#X obj 497 69 module_data \$0 \$1 \$2 \$3;
#X obj 497 92 switch~;
#X text 493 34 [module_data \$0 \$1 \$2 \$3] must be used in all module
abstractions \, otherwise the whole system will not work;
#X text 555 93 <- control the DSP of the module accodring to its activity
;
#X obj 820 601 module_output~ 0;
#X obj 836 581 module_output~ 1;
#X obj 49 371 assemble_analog_inputs 4;
#X obj 210 502 r analog_res;
#X obj 159 608 map_zero 1023 1;
#X obj 851 561 module_output~ 2;
#X obj 866 541 module_output~ 3;
#X text 50 34 you must declare the path to the generic abstractions
as they are used in all module abstractions ([get_switches] \, [assemble_analog_inputs]
\, [map] \, map_zero] \, and [module_data].;
#X text 44 201 evrey module receives potentiometer and switch data
with [r module\$1] \, where \$1 is the module index in the chain \,
starting from 1;
#X text 44 249 a leading 0 in the data received in [r module\$1] denotes
potentiomere data \, while a leading 1 denotes switch data;
#X text 234 369 <- get your potentiometer values. argument is number
of potentiometers;
#X text 130 315 <- get your potentiometer and switch data here;
#X text 322 500 <- the resolution of the analog pins is sent from the
Arduino and received in [pd init] \, in [pd moduels]. from there it
is sent to [r analog_res]. [map_zero] sets a default 10-bit resolution
since it's the standard resolution of the Arduino \, and [r analog_res]
changes it to the resolution used \, in case it's different than 10-bit
(like with the Teensy3.2 \, which is 13-bit);
#X text 793 147 the function of this module happens below \, where
we receive the scaled potentiometer values and the input signals. after
all the processing \, we send the resulting signals to the [module_output~]
abstractions which send their outputs to the matrix of the synthesizer.
;
#X text 815 625 the [module_output~] abstractions forward their incoming
signals to the matrix of the synthesizer. they are necessary in order
for each module to be connected to the rest of the system. their argument
is the output number starting from zero.;
#X obj 49 677 map_zero 1023 1023;
#X obj 110 653 r analog_res;
#X text 188 677 <- here the second potentiometer sets the range of
the first potentiometer. this way we can have a varying range \, where
the smaller the range \, the greater the resolution;
#X obj 159 630 s \$0-slope;
#X obj 214 461 s \$0-gain;
#X text 274 609 <- [map_zero] maps a range starting from 0 to the value
of the first argument to a range from 0 to the second argument;
#X obj 214 438 map 0 1023 -25 25;
#X text 345 435 <- [map] maps one value range to another. its arguments
are lowest value of original range \, highest value of original range
\, lowest value of target range \, and highest value of target range
;
#N canvas 549 226 727 627 freq 0;
#X obj 145 454 *~;
#X obj 27 594 outlet~;
#X obj 27 524 *~;
#X obj 145 537 *~;
#X obj 27 333 r \$0-freq;
#X obj 27 378 line~;
#X obj 163 432 module_input~ 1;
#X obj 202 476 input_state 1;
#X obj 202 498 pack f 20;
#X obj 202 521 line~;
#X obj 27 356 pack f 20;
#X obj 46 459 *~ -1;
#X obj 46 481 +~ 1;
#X text 21 196 we receive input signals using the [module_input~] abstraction.
this abstraction is necessary for each module to receive signals from
the rest of the system. its argument if the number of the module input
starting from zero.;
#X text 21 261 we receive the connection state of each input of the
module with the [inpust_state] abstraction. this abstraction outputs
a 1 when one or more signals are connected to it \, and a 0 when no
signal is connected.;
#X text 23 22 in this subpatch we're receiving the values of the first
two potentiometers ([r \$0-freq]) and the second input signal of the
module ([module_input~ 1]). [input_state 1] gives the connection state
of the signal input. if there is a signal (or more than one) connected
\, it will output a 1 \, otherwise it will output a zero.;
#X text 22 108 if there's no signal connected to the first input \,
we'll use the potentiometer values to control the frequency of the
filter. if there is a signal connected to the first input \, we'll
use that signal to control the frequency \, and we'll use the potentiometer
to scale the control signal.;
#X connect 0 0 3 0;
#X connect 2 0 1 0;
#X connect 3 0 1 0;
#X connect 4 0 10 0;
#X connect 5 0 2 0;
#X connect 5 0 0 0;
#X connect 6 0 0 1;
#X connect 7 0 8 0;
#X connect 8 0 9 0;
#X connect 9 0 3 1;
#X connect 9 0 11 0;
#X connect 10 0 5 0;
#X connect 11 0 12 0;
#X connect 12 0 2 1;
#X restore 848 334 pd freq;
#X obj 49 699 s \$0-freq;
#X obj 820 278 module_input~ 0;
#X obj 820 429 multiFilter_abs~;
#X obj 272 415 r analog_res;
#N canvas 545 222 676 543 slope 0;
#X obj 145 334 *~;
#X obj 27 474 outlet~;
#X obj 27 404 *~;
#X obj 145 417 *~;
#X obj 27 258 line~;
#X obj 202 378 pack f 20;
#X obj 202 401 line~;
#X obj 27 236 pack f 20;
#X obj 46 339 *~ -1;
#X obj 46 361 +~ 1;
#X obj 27 213 r \$0-slope;
#X obj 163 312 module_input~ 2;
#X obj 202 356 input_state 2;
#X text 23 22 in this subpatch we're receiving the values of the third
potentiometer ([r \$0-slope]) and the third input signal of the module
([module_input~ 2]). [input_state 2] gives the connection state of
the signal input. if there is a signal (or more than one) connected
\, it will output a 1 \, otherwise it will output a zero.;
#X text 22 108 if there's no signal connected to the first input \,
we'll use the potentiometer values to control the slope of the filter.
if there is a signal connected to the first input \, we'll use that
signal to control the slope \, and we'll use the potentiometer to scale
the control signal.;
#X connect 0 0 3 0;
#X connect 2 0 1 0;
#X connect 3 0 1 0;
#X connect 4 0 2 0;
#X connect 4 0 0 0;
#X connect 5 0 6 0;
#X connect 6 0 3 1;
#X connect 6 0 8 0;
#X connect 7 0 4 0;
#X connect 8 0 9 0;
#X connect 9 0 2 1;
#X connect 10 0 7 0;
#X connect 11 0 0 1;
#X connect 12 0 5 0;
#X restore 874 359 pd slope;
#N canvas 543 220 676 543 gain 0;
#X obj 145 334 *~;
#X obj 27 474 outlet~;
#X obj 27 404 *~;
#X obj 145 417 *~;
#X obj 27 258 line~;
#X obj 202 378 pack f 20;
#X obj 202 401 line~;
#X obj 27 236 pack f 20;
#X obj 46 339 *~ -1;
#X obj 46 361 +~ 1;
#X obj 27 213 r \$0-gain;
#X text 23 22 in this subpatch we're receiving the values of the fourth
potentiometer ([r \$0-gain]) and the third input signal of the module
([module_input~ 3]). [input_state 3] gives the connection state of
the signal input. if there is a signal (or more than one) connected
\, it will output a 1 \, otherwise it will output a zero.;
#X obj 163 312 module_input~ 3;
#X obj 202 356 input_state 3;
#X text 22 108 if there's no signal connected to the first input \,
we'll use the potentiometer values to control the gain of the filter.
if there is a signal connected to the first input \, we'll use that
signal to control the gain \, and we'll use the potentiometer to scale
the control signal.;
#X connect 0 0 3 0;
#X connect 2 0 1 0;
#X connect 3 0 1 0;
#X connect 4 0 2 0;
#X connect 4 0 0 0;
#X connect 5 0 6 0;
#X connect 6 0 3 1;
#X connect 6 0 8 0;
#X connect 7 0 4 0;
#X connect 8 0 9 0;
#X connect 9 0 2 1;
#X connect 10 0 7 0;
#X connect 12 0 0 1;
#X connect 13 0 5 0;
#X restore 901 383 pd gain;
#N canvas 88 85 930 425 set_filter_type 0;
#X msg 15 184 lowpass \$1;
#X obj 422 290 outlet;
#X msg 125 184 highpass \$1;
#X msg 235 184 bandpass \$1;
#X msg 345 184 allpass \$1;
#X msg 455 184 lowshelf \$1;
#X msg 565 184 peaknotch \$1;
#X msg 675 184 highshelf \$1;
#X msg 785 184 resonant \$1;
#X text 25 35 here we're activating or deactivating the various filter
types \, according to the connection state of the respective outlet.
if the first outlet connects to an inlet in the system \, the lowpass
filter will be activated \, and if it is disconnected \, the lowpass
filter will be deactivated. the same applies to all eight filter types.
check the help patch of [multiFilter_abs~] for more information;
#X obj 15 161 output_state 0;
#X obj 125 161 output_state 1;
#X obj 235 161 output_state 2;
#X obj 345 161 output_state 3;
#X obj 455 161 output_state 4;
#X obj 565 161 output_state 5;
#X obj 675 161 output_state 6;
#X obj 785 161 output_state 7;
#X connect 0 0 1 0;
#X connect 2 0 1 0;
#X connect 3 0 1 0;
#X connect 4 0 1 0;
#X connect 5 0 1 0;
#X connect 6 0 1 0;
#X connect 7 0 1 0;
#X connect 8 0 1 0;
#X connect 10 0 0 0;
#X connect 11 0 2 0;
#X connect 12 0 3 0;
#X connect 13 0 4 0;
#X connect 14 0 5 0;
#X connect 15 0 6 0;
#X connect 16 0 7 0;
#X connect 17 0 8 0;
#X restore 929 406 pd set_filter_type;
#X obj 882 521 module_output~ 4;
#X obj 898 501 module_output~ 5;
#X obj 913 481 module_output~ 6;
#X obj 928 461 module_output~ 7;
#X text 45 153 this module is a filter which can output eight different
filter types at the same time (check [pd set_filter_type] to see the
available filters);
#X text 128 338 <- split data according to potentiometer data index
;
#X obj 49 338 route 0;
#X text 847 311 check the four subpatches below;
#X text 943 429 <- check the help patch of this abstraction for more
info;
#X connect 2 0 45 0;
#X connect 4 0 5 0;
#X connect 10 0 23 0;
#X connect 10 1 23 2;
#X connect 10 2 12 0;
#X connect 10 3 29 0;
#X connect 11 0 12 1;
#X connect 12 0 26 0;
#X connect 23 0 32 0;
#X connect 24 0 23 1;
#X connect 29 0 27 0;
#X connect 31 0 34 1;
#X connect 33 0 34 0;
#X connect 34 0 8 0;
#X connect 34 1 9 0;
#X connect 34 2 13 0;
#X connect 34 3 14 0;
#X connect 34 4 39 0;
#X connect 34 5 40 0;
#X connect 34 6 41 0;
#X connect 34 7 42 0;
#X connect 35 0 29 2;
#X connect 36 0 34 2;
#X connect 37 0 34 3;
#X connect 38 0 34 4;
#X connect 45 0 10 0;
