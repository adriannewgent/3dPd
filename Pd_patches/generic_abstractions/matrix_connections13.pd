#N canvas 761 132 985 864 10;
#X obj 37 257 until;
#X obj 37 345 f;
#X obj 37 377 &;
#X obj 37 155 +;
#X obj 71 138 * 128;
#X msg 55 322 1;
#X obj 69 345 * 2;
#X text 69 366 bitwise AND with 1 \, 2 \, 4 \, 8 \, 16 \, 32... and
check for inequality with zero;
#X obj 37 203 f;
#X obj 37 179 t b b f b;
#X obj 560 442 t f f;
#X obj 534 340 +;
#X obj 37 299 t b b;
#X obj 534 316 f;
#X obj 566 316 + 1;
#X msg 552 196 1;
#X obj 534 512 t f f;
#X obj 37 400 != 0;
#X obj 76 445 !=;
#X obj 37 422 t f f;
#X obj 37 490 spigot;
#X obj 76 467 t f f;
#X obj 82 240 sel 1;
#X obj 172 529 f;
#X obj 566 563 list prepend element;
#X obj 566 585 list trim;
#N canvas 827 354 589 332 send_connection_states 0;
#X obj 108 169 unpack;
#X obj 147 192 t f f;
#X obj 68 262 pack;
#X obj 108 209 pack;
#X obj 34 98 inlet;
#X text 231 232 and send connection state to module abstractions;
#X obj 68 144 list split 1;
#X text 161 143 get matrix's outlet and inlet number and connection
state;
#X text 33 21 the inlet and outlet connection states are being sent
in a chain from one module to the next \, until the current inlet or
outlet number is met. no need to delay these values because they are
being delayed according to the ramp time of [mtx_*~] inside the [accumulate_connections]
abstraction;
#X obj 68 284 s inlet_states1;
#X obj 108 231 s outlet_states1;
#X obj 34 120 list split 1;
#X connect 0 0 3 0;
#X connect 0 1 1 0;
#X connect 1 0 3 1;
#X connect 1 1 2 1;
#X connect 2 0 9 0;
#X connect 3 0 10 0;
#X connect 4 0 11 0;
#X connect 6 0 2 0;
#X connect 6 1 0 0;
#X connect 11 1 6 0;
#X restore 64 666 pd send_connection_states;
#X obj 578 612 r zero_mtx;
#X obj 37 689 spigot 1;
#X obj 566 712 route float matrix;
#X obj 627 735 list prepend matrix;
#X obj 627 757 list trim;
#X text 76 260 run the loop for as many times as the number of pins
used of current input chip and stop it if you find a connection;
#N canvas 601 455 864 385 update_patching 0;
#X obj 82 153 outlet;
#X obj 27 215 outlet;
#X obj 429 215 del;
#X obj 470 198 t f f;
#X obj 470 176 spigot;
#X obj 429 103 t f f;
#X text 424 67 when patching is deactivated \, send potentiometer values
to control ramp time for [mtx_*~];
#X obj 429 126 sel 1;
#X obj 470 153 r ramp;
#X text 422 307 when patching is reactivated \, delay a bang with the
potentiometer value to set [mtx_*~] back to 15ms;
#X obj 509 120 == 0;
#X obj 429 289 s mtx_ramp;
#X obj 27 86 t f f f;
#X obj 50 109 t f f;
#X obj 82 131 sel 1;
#X text 54 172 send to module abstractions to update on-off states
;
#X obj 50 190 s update_patching;
#X obj 27 64 r patch_update_switch;
#X obj 429 262 15;
#X obj 444 238 r matrix_ramp_time;
#X connect 2 0 18 0;
#X connect 3 0 2 1;
#X connect 3 1 11 0;
#X connect 4 0 3 0;
#X connect 5 0 7 0;
#X connect 5 1 10 0;
#X connect 7 0 2 0;
#X connect 8 0 4 0;
#X connect 10 0 4 1;
#X connect 12 0 1 0;
#X connect 12 1 13 0;
#X connect 12 2 5 0;
#X connect 13 0 16 0;
#X connect 13 1 14 0;
#X connect 14 0 0 0;
#X connect 17 0 12 0;
#X connect 18 0 11 0;
#X connect 19 0 18 1;
#X restore 264 672 pd update_patching;
#X obj 566 541 pack;
#X obj 37 23 r connections;
#X text 603 539 querry current inlet/outlet connection for comparison
;
#X text 109 449 if inlet/outlet connection has changed let it through
;
#X obj 37 711 s to_mtx_mul;
#X obj 566 689 mtx;
#X obj 578 634 mtx_zeros;
#X msg 645 633 \$1 \$2;
#N canvas 981 292 542 425 signal_matrix 0;
#X msg 118 155 clear;
#N canvas 1 82 321 295 make_sends 0;
#X obj 107 103 + 100;
#X obj 107 125 pack;
#X obj 107 59 t f f;
#X obj 107 81 * 100;
#X msg 107 148 obj \$1 150 send~ input\$2;
#X obj 61 10 inlet;
#X obj 107 170 outlet make_obj;
#X obj 61 197 outlet done;
#N canvas 1 82 329 255 loop 0;
#X obj 61 75 until;
#X obj 61 120 f;
#X obj 91 120 + 1;
#X obj 61 142 t f f;
#X obj 61 190 sel;
#X obj 79 166 - 1;
#X obj 131 159 outlet;
#X obj 61 212 outlet;
#X obj 61 31 inlet;
#X obj 61 53 t f b f;
#X msg 79 97 0;
#X connect 0 0 1 0;
#X connect 1 0 2 0;
#X connect 1 0 3 0;
#X connect 2 0 1 1;
#X connect 3 0 4 0;
#X connect 3 1 6 0;
#X connect 4 0 7 0;
#X connect 5 0 4 1;
#X connect 8 0 9 0;
#X connect 9 0 0 0;
#X connect 9 1 10 0;
#X connect 9 2 5 0;
#X connect 10 0 1 1;
#X restore 61 36 pd loop;
#X connect 0 0 1 0;
#X connect 1 0 4 0;
#X connect 2 0 3 0;
#X connect 2 1 1 1;
#X connect 3 0 0 0;
#X connect 4 0 6 0;
#X connect 5 0 8 0;
#X connect 8 0 7 0;
#X connect 8 1 2 0;
#X restore 37 265 pd make_sends;
#N canvas 1 82 315 289 make_receives 0;
#X msg 109 122 obj 10 50 r to_mtx_mul;
#X msg 86 146 obj 10 150 r mtx_ramp;
#X obj 63 97 t b b b;
#X obj 63 71 inlet;
#X obj 109 175 outlet make_obj;
#X obj 63 197 outlet done;
#X connect 0 0 4 0;
#X connect 1 0 4 0;
#X connect 2 0 5 0;
#X connect 2 1 1 0;
#X connect 2 2 0 0;
#X connect 3 0 2 0;
#X restore 37 291 pd make_receives;
#N canvas 321 174 504 576 make_connections 0;
#X text 206 124 connect to [mtx_*~];
#X text 206 290 connect from [mtx_*~];
#X obj 35 10 inlet;
#X obj 81 100 + 1;
#X msg 81 289 connect 0 \$1 \$2 0;
#X obj 113 245 +;
#X obj 128 223 + 1;
#X msg 81 123 connect \$1 0 0 \$1;
#X obj 81 200 t f f;
#X obj 81 267 pack;
#X obj 35 54 t f f;
#X obj 35 389 +;
#X obj 35 411 + 1;
#X obj 35 433 t f f;
#X obj 35 455 + 1;
#X msg 105 450 connect \$1 0 0 0;
#X msg 35 503 connect \$1 0 0 \$2;
#X obj 35 342 t f f;
#X obj 67 455 + 1;
#X obj 35 479 pack;
#X obj 303 425 outlet connections;
#X obj 391 116 unpack;
#X obj 35 32 f;
#X obj 35 156 f;
#X obj 391 94 inlet list;
#X obj 391 139 t f f;
#X obj 35 320 f;
#X obj 430 303 t f f;
#N canvas 1 83 329 255 loop 0;
#X obj 61 75 until;
#X obj 61 120 f;
#X obj 91 120 + 1;
#X obj 61 142 t f f;
#X obj 61 190 sel;
#X obj 79 166 - 1;
#X obj 131 159 outlet;
#X obj 61 212 outlet;
#X obj 61 31 inlet;
#X obj 61 53 t f b f;
#X msg 79 97 0;
#X connect 0 0 1 0;
#X connect 1 0 2 0;
#X connect 1 0 3 0;
#X connect 2 0 1 1;
#X connect 3 0 4 0;
#X connect 3 1 6 0;
#X connect 4 0 7 0;
#X connect 5 0 4 1;
#X connect 8 0 9 0;
#X connect 9 0 0 0;
#X connect 9 1 10 0;
#X connect 9 2 5 0;
#X connect 10 0 1 1;
#X restore 35 78 pd loop;
#N canvas 1 83 329 255 loop 0;
#X obj 61 75 until;
#X obj 61 120 f;
#X obj 91 120 + 1;
#X obj 61 142 t f f;
#X obj 61 190 sel;
#X obj 79 166 - 1;
#X obj 131 159 outlet;
#X obj 61 212 outlet;
#X obj 61 31 inlet;
#X obj 61 53 t f b f;
#X msg 79 99 0;
#X connect 0 0 1 0;
#X connect 1 0 2 0;
#X connect 1 0 3 0;
#X connect 2 0 1 1;
#X connect 3 0 4 0;
#X connect 3 1 6 0;
#X connect 4 0 7 0;
#X connect 5 0 4 1;
#X connect 8 0 9 0;
#X connect 9 0 0 0;
#X connect 9 1 10 0;
#X connect 9 2 5 0;
#X connect 10 0 1 1;
#X restore 35 178 pd loop;
#X obj 35 525 t b a;
#X obj 35 547 outlet done;
#X connect 2 0 22 0;
#X connect 3 0 7 0;
#X connect 4 0 20 0;
#X connect 5 0 9 1;
#X connect 6 0 5 1;
#X connect 7 0 20 0;
#X connect 8 0 9 0;
#X connect 8 1 5 0;
#X connect 9 0 4 0;
#X connect 10 0 28 0;
#X connect 10 1 6 0;
#X connect 11 0 12 0;
#X connect 12 0 13 0;
#X connect 13 0 14 0;
#X connect 13 1 15 0;
#X connect 14 0 19 0;
#X connect 15 0 20 0;
#X connect 16 0 30 0;
#X connect 17 0 11 0;
#X connect 17 1 18 0;
#X connect 18 0 19 1;
#X connect 19 0 16 0;
#X connect 21 0 25 0;
#X connect 21 1 27 0;
#X connect 22 0 10 0;
#X connect 23 0 29 0;
#X connect 24 0 21 0;
#X connect 25 0 23 1;
#X connect 25 1 11 1;
#X connect 26 0 17 0;
#X connect 27 0 26 1;
#X connect 27 1 22 1;
#X connect 28 0 23 0;
#X connect 28 1 3 0;
#X connect 29 0 26 0;
#X connect 29 1 8 0;
#X connect 30 0 31 0;
#X connect 30 1 20 0;
#X restore 37 316 pd make_connections;
#X obj 37 190 t l l l;
#X obj 37 24 r num_io;
#X obj 37 340 list;
#X obj 37 362 outlet;
#X obj 37 138 t l l b;
#X obj 220 257 s pd-matrix;
#N canvas 1 191 1234 315 matrix 0;
#X restore 37 390 pd matrix;
#N canvas 639 83 362 364 make_catches 0;
#X obj 120 205 + 100;
#X msg 120 250 obj \$1 50 catch~ output\$2;
#X obj 120 227 pack;
#X obj 120 161 t f f;
#X obj 81 27 inlet;
#X obj 120 272 outlet make_obj;
#X obj 120 183 * 110;
#X obj 81 49 unpack;
#X obj 81 298 outlet num_outlets;
#X obj 120 94 until;
#X obj 120 139 f;
#X obj 150 139 + 1;
#X obj 120 71 t f b;
#X msg 138 117 0;
#X connect 0 0 2 0;
#X connect 1 0 5 0;
#X connect 2 0 1 0;
#X connect 3 0 6 0;
#X connect 3 1 2 1;
#X connect 4 0 7 0;
#X connect 6 0 0 0;
#X connect 7 0 8 0;
#X connect 7 1 12 0;
#X connect 9 0 10 0;
#X connect 10 0 11 0;
#X connect 10 0 3 0;
#X connect 11 0 10 1;
#X connect 12 0 9 0;
#X connect 12 1 13 0;
#X connect 13 0 10 1;
#X restore 37 240 pd make_catches;
#X obj 37 46 unpack f f f f;
#X obj 37 68 bug13;
#X obj 91 73 bug13;
#X obj 37 110 pack f f \$1;
#X msg 220 207 obj 100 100 mtx_*~ \$1 \$2 \$3 ...........................................
;
#X obj 215 25 loadbang;
#X obj 215 47 \$1;
#X obj 215 129 s matrix_ramp_time;
#X text 211 150 send the matrix ramp time to all [module_data] \, [input_state]
and [output_state] abstractions;
#X obj 215 69 sel 0;
#X msg 215 91 100;
#X connect 0 0 9 0;
#X connect 1 0 2 0;
#X connect 1 1 9 0;
#X connect 2 0 3 0;
#X connect 2 1 9 0;
#X connect 3 0 6 0;
#X connect 3 1 9 0;
#X connect 4 0 11 0;
#X connect 4 1 3 1;
#X connect 4 2 16 0;
#X connect 5 0 12 0;
#X connect 6 0 7 0;
#X connect 8 0 4 0;
#X connect 8 1 6 1;
#X connect 8 2 0 0;
#X connect 11 0 1 0;
#X connect 11 1 9 0;
#X connect 12 0 13 0;
#X connect 12 1 13 1;
#X connect 12 2 14 0;
#X connect 12 3 14 1;
#X connect 13 0 15 0;
#X connect 14 0 15 1;
#X connect 15 0 8 0;
#X connect 16 0 9 0;
#X connect 17 0 18 0;
#X connect 18 0 21 0;
#X connect 21 0 22 0;
#X connect 21 1 19 0;
#X connect 22 0 19 0;
#X restore 645 611 pd signal_matrix;
#X text 69 204 <- num input pins;
#X text 602 442 <- output pin number;
#X text 565 341 <- total num of input pins of previous modules;
#X obj 37 48 unpack f f f f f f f f f f;
#X obj 37 118 bug13;
#X obj 71 98 bug13;
#X obj 105 77 bug13;
#X obj 139 97 bug13;
#X obj 173 77 bug13;
#X text 228 42 incoming bytes are input byte (split in two) \, number
of input pins of current module \, output pin number \, and total number
of input pins of previous modules \, all with their 13_bug fixes;
#N canvas 36 229 744 646 debounce_connections 0;
#X obj 65 80 inlet state;
#N canvas 1173 297 580 306 compare_lists 0;
#X obj 18 95 unpack f f;
#X obj 18 160 ==;
#X obj 75 167 ==;
#X obj 18 50 inlet stored_pairs;
#X obj 158 50 inlet new_pair;
#X obj 18 196 &&;
#X obj 18 228 outlet;
#X text 54 191 if both values are the same with a pair in the list
\, then we'll store to that matrix index;
#X obj 18 72 list split 2;
#X obj 158 72 unpack f f;
#X connect 0 0 1 0;
#X connect 0 1 2 0;
#X connect 1 0 5 0;
#X connect 2 0 5 1;
#X connect 3 0 8 0;
#X connect 4 0 9 0;
#X connect 5 0 6 0;
#X connect 8 0 0 0;
#X connect 9 0 1 1;
#X connect 9 1 2 1;
#X restore 348 406 pd compare_lists;
#X obj 244 344 mtx 10 3;
#X obj 223 314 mtx_zeros 10 3;
#X msg 244 267 row \$1;
#X obj 348 428 sel 1;
#X obj 244 245 t f f;
#X obj 447 484 t b b;
#X obj 447 506 f;
#X obj 65 568 list append;
#N canvas 35 333 345 362 loop 0;
#X obj 55 51 inlet;
#X msg 55 94 10;
#X obj 55 186 until;
#X obj 85 231 + 1;
#X obj 55 231 1;
#X msg 70 206 1;
#X obj 55 253 t f f;
#X obj 55 297 t b b;
#X obj 55 319 outlet done;
#X obj 155 270 outlet;
#X obj 122 169 inlet stop;
#X obj 55 73 route bang float;
#X obj 55 275 sel;
#X obj 55 116 t f b f;
#X connect 0 0 11 0;
#X connect 1 0 13 0;
#X connect 2 0 4 0;
#X connect 3 0 4 1;
#X connect 4 0 3 0;
#X connect 4 0 6 0;
#X connect 5 0 4 1;
#X connect 6 0 12 0;
#X connect 6 1 9 0;
#X connect 7 0 8 0;
#X connect 10 0 2 1;
#X connect 11 0 1 0;
#X connect 11 1 13 0;
#X connect 12 0 7 0;
#X connect 13 0 2 0;
#X connect 13 1 5 0;
#X connect 13 2 12 1;
#X restore 205 217 pd loop;
#X text 394 428 if a pair is already stored we use that index;
#N canvas 346 138 452 332 check_if_empty 0;
#X obj 43 106 inlet;
#X obj 70 155 list split 1;
#X obj 124 194 == 0;
#X obj 43 128 t l l;
#X obj 43 268 outlet to_compare;
#X obj 124 216 sel 1;
#X text 44 40 since matrix rows and colums start counting from 1 \,
a 0 will denote an "empty" slot. this means that we can stop looping
and we can use the current loop index to write a new entry to;
#X obj 124 238 outlet found_empty_slot;
#X obj 43 202 spigot;
#X obj 70 177 t f f;
#X connect 0 0 3 0;
#X connect 1 0 9 0;
#X connect 2 0 5 0;
#X connect 3 0 8 0;
#X connect 3 1 1 0;
#X connect 5 0 7 0;
#X connect 8 0 4 0;
#X connect 9 0 8 1;
#X connect 9 1 2 0;
#X restore 348 383 pd check_if_empty;
#X obj 65 545 pack;
#X obj 205 194 t b l l l;
#X obj 440 120 list append;
#X obj 65 103 t f f;
#X obj 440 164 outlet to_ctl_mtx;
#X obj 244 390 outlet msg_pass;
#N canvas 555 233 453 293 route_mtx 0;
#X obj 19 86 inlet;
#X obj 88 138 t a a;
#X obj 88 190 spigot;
#X obj 200 182 outlet;
#X obj 19 108 route matrix;
#X obj 206 33 r \$0-debounce_start;
#X msg 206 55 1;
#X obj 206 77 t f f;
#X obj 121 168 == 0;
#X msg 262 77 0;
#X obj 262 55 oreceive \$0-debounce_end 0;
#X obj 200 155 spigot;
#X obj 88 212 list prepend element;
#X obj 88 234 list trim;
#X obj 88 256 outlet pass;
#X connect 0 0 4 0;
#X connect 1 0 2 0;
#X connect 1 1 11 0;
#X connect 2 0 12 0;
#X connect 4 1 1 0;
#X connect 5 0 6 0;
#X connect 6 0 7 0;
#X connect 7 0 8 0;
#X connect 7 1 11 1;
#X connect 8 0 2 1;
#X connect 9 0 7 0;
#X connect 10 0 9 0;
#X connect 11 0 3 0;
#X connect 12 0 13 0;
#X connect 13 0 14 0;
#X restore 244 366 pd route_mtx;
#N canvas 192 274 334 403 time_input 0;
#X obj 58 59 inlet;
#X obj 58 81 spigot 1;
#X msg 133 120 0;
#X obj 58 103 t b b;
#X obj 58 265 del 100;
#X obj 58 287 t b b;
#X msg 85 309 1;
#X obj 58 333 s \$0-debounce_end;
#X obj 58 125 t b b;
#X obj 154 142 s \$0-debounce_start;
#X obj 70 194 loadbang;
#X obj 70 216 \$2;
#X obj 70 238 sel 0;
#X connect 0 0 1 0;
#X connect 1 0 3 0;
#X connect 2 0 1 1;
#X connect 3 0 8 0;
#X connect 3 1 2 0;
#X connect 4 0 5 0;
#X connect 5 0 7 0;
#X connect 5 1 6 0;
#X connect 6 0 1 1;
#X connect 8 0 4 0;
#X connect 8 1 9 0;
#X connect 10 0 11 0;
#X connect 11 0 12 0;
#X connect 12 1 4 1;
#X restore 232 171 pd time_input;
#X text 293 268 get all rows one by one;
#X obj 474 550 max 1;
#X obj 447 528 t f f;
#X msg 501 528 1;
#X obj 205 439 s \$0-done;
#X obj 501 506 r \$0-done;
#X obj 223 292 r \$0-done;
#X text 307 337 it's quite unlikely to be able to make ten different
connections at the same time...;
#X obj 459 600 f;
#X obj 459 576 oreceive \$0-debounce_end 2;
#X obj 205 148 t l b;
#N canvas 1 83 450 300 zero_local_mtx 0;
#X obj 87 39 inlet;
#X obj 87 138 spigot;
#X obj 87 160 outlet;
#X obj 178 99 oreceive \$0-debounce_end 1;
#X msg 178 121 1;
#X obj 120 67 r \$0-debounce_start;
#X msg 120 89 0;
#X connect 0 0 1 0;
#X connect 1 0 2 0;
#X connect 3 0 4 0;
#X connect 4 0 1 1;
#X connect 5 0 6 0;
#X connect 6 0 1 1;
#X restore 205 417 pd zero_local_mtx;
#X msg 440 142 element \$2 \$3 \$1;
#X text 45 8 the first two values are outlet and inlet \, so if any
of the two changes \, then we're in a new connection/disconnection
set so we need to store them;
#X obj 205 126 inlet inlet_outlet;
#X msg 65 591 row \$2 \$3 \$4 \$1;
#X connect 0 0 16 0;
#X connect 1 0 5 0;
#X connect 2 0 19 0;
#X connect 3 0 2 0;
#X connect 4 0 2 0;
#X connect 5 0 7 0;
#X connect 6 0 4 0;
#X connect 6 1 8 1;
#X connect 7 0 8 0;
#X connect 7 1 10 1;
#X connect 8 0 23 0;
#X connect 9 0 36 0;
#X connect 10 0 32 0;
#X connect 10 1 6 0;
#X connect 12 0 1 0;
#X connect 12 1 7 0;
#X connect 13 0 9 0;
#X connect 14 0 10 0;
#X connect 14 1 9 1;
#X connect 14 2 15 1;
#X connect 14 3 1 1;
#X connect 15 0 33 0;
#X connect 16 0 13 0;
#X connect 16 1 15 0;
#X connect 19 0 18 0;
#X connect 19 1 12 0;
#X connect 22 0 29 1;
#X connect 23 0 13 1;
#X connect 23 1 22 0;
#X connect 24 0 22 1;
#X connect 26 0 24 0;
#X connect 27 0 3 0;
#X connect 29 0 10 0;
#X connect 30 0 29 0;
#X connect 31 0 14 0;
#X connect 31 1 20 0;
#X connect 32 0 25 0;
#X connect 33 0 17 0;
#X connect 35 0 31 0;
#X connect 36 0 2 0;
#X restore 37 575 pd debounce_connections;
#X obj 37 512 t f b;
#X obj 37 643 t a a;
#X obj 172 554 pack;
#X text 191 572 update the control matrix so that the elements comparison
above works as expected;
#X obj 605 679 s \$0-seconday_mtx;
#X obj 578 656 t a a;
#N canvas 310 381 614 434 second_debounce 0;
#X text 12 14 the debouncing algorithm above works but it will still
output a connection that is already there \, when the patch cords are
being touched;
#X text 12 63 here we avoid letting an existing connection go through
\, in order to avoid clicks that occur from the matrix connections
;
#X obj 26 113 inlet;
#X obj 26 160 t a a;
#X obj 130 177 list split 3;
#X obj 130 199 list trim;
#X obj 130 253 mtx;
#X obj 26 135 t a a;
#X obj 210 359 list;
#X obj 139 226 r \$0-seconday_mtx;
#X obj 26 359 spigot;
#X obj 130 298 ==;
#X obj 130 320 t f f;
#X obj 130 342 == 0;
#X obj 26 381 outlet;
#X obj 210 337 sel 0;
#X obj 210 381 list trim;
#X text 210 316 if the connections doesn't exist let it through and
store it;
#X obj 130 275 route float;
#X connect 2 0 7 0;
#X connect 3 0 10 0;
#X connect 3 1 4 0;
#X connect 4 0 5 0;
#X connect 4 1 11 1;
#X connect 5 0 6 0;
#X connect 6 0 18 0;
#X connect 7 0 3 0;
#X connect 7 1 8 1;
#X connect 8 0 16 0;
#X connect 9 0 6 0;
#X connect 10 0 14 0;
#X connect 11 0 12 0;
#X connect 12 0 13 0;
#X connect 12 1 15 0;
#X connect 13 0 10 1;
#X connect 15 0 8 0;
#X connect 16 0 6 0;
#X connect 18 0 11 0;
#X restore 37 602 pd second_debounce;
#X text 619 660 this goes into [pd second_debounce;
#X connect 0 0 12 0;
#X connect 1 0 6 0;
#X connect 1 0 2 0;
#X connect 2 0 17 0;
#X connect 3 0 9 0;
#X connect 4 0 3 1;
#X connect 5 0 1 1;
#X connect 6 0 1 1;
#X connect 8 0 0 0;
#X connect 9 0 8 0;
#X connect 9 1 5 0;
#X connect 9 2 2 1;
#X connect 9 3 15 0;
#X connect 10 0 56 1;
#X connect 10 1 34 1;
#X connect 11 0 16 0;
#X connect 12 0 1 0;
#X connect 12 1 13 0;
#X connect 13 0 14 0;
#X connect 13 0 11 0;
#X connect 14 0 13 1;
#X connect 15 0 13 1;
#X connect 16 0 23 1;
#X connect 16 1 34 0;
#X connect 17 0 19 0;
#X connect 18 0 21 0;
#X connect 19 0 20 0;
#X connect 19 1 18 0;
#X connect 20 0 54 0;
#X connect 21 0 20 1;
#X connect 21 1 22 0;
#X connect 22 0 0 1;
#X connect 23 0 56 0;
#X connect 24 0 25 0;
#X connect 25 0 39 0;
#X connect 27 0 40 0;
#X connect 28 0 38 0;
#X connect 29 0 18 1;
#X connect 29 1 30 0;
#X connect 30 0 31 0;
#X connect 31 0 38 0;
#X connect 33 0 28 1;
#X connect 33 1 39 0;
#X connect 34 0 24 0;
#X connect 35 0 46 0;
#X connect 39 0 29 0;
#X connect 40 0 59 0;
#X connect 41 0 40 0;
#X connect 42 0 41 0;
#X connect 46 0 47 0;
#X connect 46 1 47 1;
#X connect 46 2 48 0;
#X connect 46 3 48 1;
#X connect 46 4 49 0;
#X connect 46 5 49 1;
#X connect 46 6 50 0;
#X connect 46 7 50 1;
#X connect 46 8 51 0;
#X connect 46 9 51 1;
#X connect 47 0 3 0;
#X connect 48 0 4 0;
#X connect 49 0 8 1;
#X connect 50 0 10 0;
#X connect 51 0 11 1;
#X connect 53 0 60 0;
#X connect 53 1 39 0;
#X connect 54 0 53 0;
#X connect 54 1 23 0;
#X connect 55 0 28 0;
#X connect 55 1 26 0;
#X connect 56 0 53 1;
#X connect 59 0 39 0;
#X connect 59 1 58 0;
#X connect 60 0 55 0;
