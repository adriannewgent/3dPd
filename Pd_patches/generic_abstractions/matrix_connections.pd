#N canvas 748 144 1106 795 10;
#X obj 37 217 until;
#X obj 37 305 f;
#X obj 37 337 &;
#X obj 37 115 +;
#X obj 71 98 * 128;
#X msg 55 282 1;
#X obj 69 305 * 2;
#X text 69 326 bitwise AND with 1 \, 2 \, 4 \, 8 \, 16 \, 32... and
check for inequality with zero;
#X obj 37 163 f;
#X obj 37 139 t b b f b;
#X obj 639 402 t f f;
#X obj 614 300 +;
#X obj 37 259 t b b;
#X obj 614 276 f;
#X obj 646 276 + 1;
#X msg 632 156 1;
#X obj 614 472 t f f;
#X obj 37 360 != 0;
#X obj 76 405 !=;
#X obj 37 382 t f f;
#X obj 37 450 spigot;
#X obj 195 489 f;
#X obj 646 523 list prepend element;
#X obj 646 545 list trim;
#X obj 658 572 r zero_mtx;
#X obj 349 655 spigot 1;
#X obj 646 672 route float matrix;
#X obj 707 695 list prepend matrix;
#X obj 707 717 list trim;
#X text 76 220 run the loop for as many times as the number of pins
used of current input chip and stop it if you find a connection;
#N canvas 595 449 864 385 update_patching 0;
#X obj 82 153 outlet;
#X obj 27 215 outlet;
#X obj 429 215 del;
#X obj 470 198 t f f;
#X obj 470 176 spigot;
#X obj 429 103 t f f;
#X text 424 67 when patching is deactivated \, send potentiometer values
to control ramp time for [mtx_*~];
#X obj 429 126 sel 1;
#X obj 470 153 r ramp;
#X text 422 307 when patching is reactivated \, delay a bang with the
potentiometer value to set [mtx_*~] back to 15ms;
#X obj 509 120 == 0;
#X obj 429 289 s mtx_ramp;
#X obj 27 86 t f f f;
#X obj 50 109 t f f;
#X obj 82 131 sel 1;
#X text 54 172 send to module abstractions to update on-off states
;
#X obj 50 190 s update_patching;
#X obj 27 64 r patch_update_switch;
#X obj 447 238 r matrix_ramp_time;
#X obj 429 262 100;
#X connect 2 0 19 0;
#X connect 3 0 2 1;
#X connect 3 1 11 0;
#X connect 4 0 3 0;
#X connect 5 0 7 0;
#X connect 5 1 10 0;
#X connect 7 0 2 0;
#X connect 8 0 4 0;
#X connect 10 0 4 1;
#X connect 12 0 1 0;
#X connect 12 1 13 0;
#X connect 12 2 5 0;
#X connect 13 0 16 0;
#X connect 13 1 14 0;
#X connect 14 0 0 0;
#X connect 17 0 12 0;
#X connect 18 0 19 1;
#X connect 19 0 11 0;
#X restore 402 632 pd update_patching;
#X obj 646 501 pack;
#X obj 37 23 r connections;
#X text 683 499 querry current inlet/outlet connection for comparison
;
#X text 109 409 if inlet/outlet connection has changed let it through
;
#X obj 646 649 mtx;
#X obj 658 594 mtx_zeros;
#X text 69 164 <- num input pins;
#X text 681 402 <- output pin number;
#X text 645 301 <- total num of input pins of previous modules;
#N canvas 34 227 807 654 debounce_connections 0;
#X obj 65 80 inlet state;
#N canvas 1171 295 580 306 compare_lists 0;
#X obj 18 95 unpack f f;
#X obj 18 160 ==;
#X obj 85 167 ==;
#X obj 18 50 inlet stored_pairs;
#X obj 158 50 inlet new_pair;
#X obj 18 196 &&;
#X obj 18 228 outlet;
#X text 54 191 if both values are the same with a pair in the list
\, then we'll store to that matrix index;
#X obj 18 72 list split 2;
#X obj 158 72 unpack f f;
#X connect 0 0 1 0;
#X connect 0 1 2 0;
#X connect 1 0 5 0;
#X connect 2 0 5 1;
#X connect 3 0 8 0;
#X connect 4 0 9 0;
#X connect 5 0 6 0;
#X connect 8 0 0 0;
#X connect 9 0 1 1;
#X connect 9 1 2 1;
#X restore 375 406 pd compare_lists;
#X obj 251 344 mtx 10 3;
#X obj 230 314 mtx_zeros 10 3;
#X msg 251 267 row \$1;
#X obj 375 428 sel 1;
#X obj 251 245 t f f;
#X obj 491 484 t b b;
#X obj 491 506 f;
#X obj 65 568 list append;
#N canvas 35 333 345 362 loop 0;
#X obj 55 51 inlet;
#X msg 55 94 10;
#X obj 55 186 until;
#X obj 85 231 + 1;
#X obj 55 231 1;
#X msg 70 206 1;
#X obj 55 253 t f f;
#X obj 55 297 t b b;
#X obj 55 319 outlet done;
#X obj 155 270 outlet;
#X obj 122 169 inlet stop;
#X obj 55 73 route bang float;
#X obj 55 275 sel;
#X obj 55 116 t f b f;
#X connect 0 0 11 0;
#X connect 1 0 13 0;
#X connect 2 0 4 0;
#X connect 3 0 4 1;
#X connect 4 0 3 0;
#X connect 4 0 6 0;
#X connect 5 0 4 1;
#X connect 6 0 12 0;
#X connect 6 1 9 0;
#X connect 7 0 8 0;
#X connect 10 0 2 1;
#X connect 11 0 1 0;
#X connect 11 1 13 0;
#X connect 12 0 7 0;
#X connect 13 0 2 0;
#X connect 13 1 5 0;
#X connect 13 2 12 1;
#X restore 205 217 pd loop;
#X text 421 428 if a pair is already stored we use that index;
#N canvas 344 136 558 331 check_if_empty 0;
#X obj 43 106 inlet;
#X obj 82 155 list split 1;
#X obj 136 194 == 0;
#X obj 43 128 t l l;
#X obj 43 268 outlet to_compare;
#X obj 136 216 sel 1;
#X text 44 40 since matrix rows and colums start counting from 1 \,
a 0 will denote an "empty" slot. this means that we can stop looping
and we can use the current loop index to write a new entry to;
#X obj 136 238 outlet found_empty_slot;
#X obj 43 202 spigot;
#X obj 82 177 t f f;
#X connect 0 0 3 0;
#X connect 1 0 9 0;
#X connect 2 0 5 0;
#X connect 3 0 8 0;
#X connect 3 1 1 0;
#X connect 5 0 7 0;
#X connect 8 0 4 0;
#X connect 9 0 8 1;
#X connect 9 1 2 0;
#X restore 375 383 pd check_if_empty;
#X obj 65 545 pack;
#X obj 205 194 t b l l l;
#X obj 440 120 list append;
#X obj 65 103 t f f;
#X obj 440 164 outlet to_ctl_mtx;
#X obj 251 390 outlet msg_pass;
#N canvas 551 229 513 308 route_mtx 0;
#X obj 19 86 inlet;
#X obj 100 138 t a a;
#X obj 100 190 spigot;
#X obj 211 182 outlet;
#X obj 19 108 route matrix;
#X obj 218 33 r \$0-debounce_start;
#X msg 218 55 1;
#X obj 218 77 t f f;
#X obj 139 168 == 0;
#X msg 274 77 0;
#X obj 274 55 oreceive \$0-debounce_end 0;
#X obj 211 155 spigot;
#X obj 100 212 list prepend element;
#X obj 100 234 list trim;
#X obj 100 256 outlet pass;
#X connect 0 0 4 0;
#X connect 1 0 2 0;
#X connect 1 1 11 0;
#X connect 2 0 12 0;
#X connect 4 1 1 0;
#X connect 5 0 6 0;
#X connect 6 0 7 0;
#X connect 7 0 8 0;
#X connect 7 1 11 1;
#X connect 8 0 2 1;
#X connect 9 0 7 0;
#X connect 10 0 9 0;
#X connect 11 0 3 0;
#X connect 12 0 13 0;
#X connect 13 0 14 0;
#X restore 251 366 pd route_mtx;
#N canvas 190 272 334 403 time_input 0;
#X obj 58 59 inlet;
#X obj 58 81 spigot 1;
#X msg 133 120 0;
#X obj 58 103 t b b;
#X obj 58 265 del 100;
#X obj 58 287 t b b;
#X msg 90 309 1;
#X obj 58 333 s \$0-debounce_end;
#X obj 58 125 t b b;
#X obj 154 142 s \$0-debounce_start;
#X obj 72 194 loadbang;
#X obj 72 216 \$2;
#X obj 72 238 sel 0;
#X connect 0 0 1 0;
#X connect 1 0 3 0;
#X connect 2 0 1 1;
#X connect 3 0 8 0;
#X connect 3 1 2 0;
#X connect 4 0 5 0;
#X connect 5 0 7 0;
#X connect 5 1 6 0;
#X connect 6 0 1 1;
#X connect 8 0 4 0;
#X connect 8 1 9 0;
#X connect 10 0 11 0;
#X connect 11 0 12 0;
#X connect 12 1 4 1;
#X restore 237 171 pd time_input;
#X text 300 268 get all rows one by one;
#X obj 523 550 max 1;
#X obj 491 528 t f f;
#X msg 555 528 1;
#X obj 205 439 s \$0-done;
#X obj 555 506 r \$0-done;
#X obj 230 292 r \$0-done;
#X text 314 337 it's quite unlikely to be able to make ten different
connections at the same time...;
#X obj 505 600 f;
#X obj 505 576 oreceive \$0-debounce_end 2;
#X obj 205 148 t l b;
#N canvas 1 82 450 300 zero_local_mtx 0;
#X obj 87 39 inlet;
#X obj 87 138 spigot;
#X obj 87 160 outlet;
#X obj 178 99 oreceive \$0-debounce_end 1;
#X msg 178 121 1;
#X obj 126 67 r \$0-debounce_start;
#X msg 126 89 0;
#X connect 0 0 1 0;
#X connect 1 0 2 0;
#X connect 3 0 4 0;
#X connect 4 0 1 1;
#X connect 5 0 6 0;
#X connect 6 0 1 1;
#X restore 205 417 pd zero_local_mtx;
#X msg 440 142 element \$2 \$3 \$1;
#X text 45 8 the first two values are outlet and inlet \, so if any
of the two changes \, then we're in a new connection/disconnection
set so we need to store them;
#X obj 205 126 inlet inlet_outlet;
#X msg 65 591 row \$2 \$3 \$4 \$1;
#X connect 0 0 16 0;
#X connect 1 0 5 0;
#X connect 2 0 19 0;
#X connect 3 0 2 0;
#X connect 4 0 2 0;
#X connect 5 0 7 0;
#X connect 6 0 4 0;
#X connect 6 1 8 1;
#X connect 7 0 8 0;
#X connect 7 1 10 1;
#X connect 8 0 23 0;
#X connect 9 0 36 0;
#X connect 10 0 32 0;
#X connect 10 1 6 0;
#X connect 12 0 1 0;
#X connect 12 1 7 0;
#X connect 13 0 9 0;
#X connect 14 0 10 0;
#X connect 14 1 9 1;
#X connect 14 2 15 1;
#X connect 14 3 1 1;
#X connect 15 0 33 0;
#X connect 16 0 13 0;
#X connect 16 1 15 0;
#X connect 19 0 18 0;
#X connect 19 1 12 0;
#X connect 22 0 29 1;
#X connect 23 0 13 1;
#X connect 23 1 22 0;
#X connect 24 0 22 1;
#X connect 26 0 24 0;
#X connect 27 0 3 0;
#X connect 29 0 10 0;
#X connect 30 0 29 0;
#X connect 31 0 14 0;
#X connect 31 1 20 0;
#X connect 32 0 25 0;
#X connect 33 0 17 0;
#X connect 35 0 31 0;
#X connect 36 0 2 0;
#X restore 37 535 pd debounce_connections;
#X obj 37 472 t f b;
#X obj 195 514 pack;
#X text 206 532 update the control matrix so that the elements comparison
above works as expected;
#X obj 690 639 s \$0-seconday_mtx;
#X obj 658 616 t a a;
#N canvas 308 379 682 438 second_debounce 0;
#X text 12 14 the debouncing algorithm above works but it will still
output a connection that is already there \, when the patch cords are
being touched;
#X text 12 63 here we avoid letting an existing connection go through
\, in order to avoid clicks that occur from the matrix connections
;
#X obj 26 113 inlet;
#X obj 26 160 t a a;
#X obj 130 177 list split 3;
#X obj 130 199 list trim;
#X obj 130 253 mtx;
#X obj 26 135 t a a;
#X obj 210 359 list;
#X obj 139 226 r \$0-seconday_mtx;
#X obj 26 359 spigot;
#X obj 130 298 ==;
#X obj 130 320 t f f;
#X obj 130 342 == 0;
#X obj 26 381 outlet;
#X obj 210 337 sel 0;
#X obj 210 381 list trim;
#X text 210 316 if the connections doesn't exist let it through and
store it;
#X obj 130 275 route float;
#X connect 2 0 7 0;
#X connect 3 0 10 0;
#X connect 3 1 4 0;
#X connect 4 0 5 0;
#X connect 4 1 11 1;
#X connect 5 0 6 0;
#X connect 6 0 18 0;
#X connect 7 0 3 0;
#X connect 7 1 8 1;
#X connect 8 0 16 0;
#X connect 9 0 6 0;
#X connect 10 0 14 0;
#X connect 11 0 12 0;
#X connect 12 0 13 0;
#X connect 12 1 15 0;
#X connect 13 0 10 1;
#X connect 15 0 8 0;
#X connect 16 0 6 0;
#X connect 18 0 11 0;
#X restore 37 562 pd second_debounce;
#X obj 37 48 unpack f f f f f;
#N canvas 823 350 589 332 send_connection_states 0;
#X obj 74 169 unpack;
#X obj 113 192 t f f;
#X obj 34 262 pack;
#X obj 74 209 pack;
#X obj 34 98 inlet;
#X text 192 232 and send connection state to module abstractions;
#X obj 34 144 list split 1;
#X text 127 143 get matrix's outlet and inlet number and connection
state;
#X text 33 21 the inlet and outlet connection states are being sent
in a chain from one module to the next \, until the current inlet or
outlet number is met. no need to delay these values because they are
being delayed according to the ramp time of [mtx_*~] inside the [accumulate_connections]
abstraction;
#X obj 74 231 s outlet_states0;
#X obj 34 284 s inlet_states0;
#X connect 0 0 3 0;
#X connect 0 1 1 0;
#X connect 1 0 3 1;
#X connect 1 1 2 1;
#X connect 2 0 10 0;
#X connect 3 0 9 0;
#X connect 4 0 6 0;
#X connect 6 0 2 0;
#X connect 6 1 0 0;
#X restore 109 714 pd send_connection_states;
#X obj 37 662 list split 1;
#X text 137 661 remove the word "element";
#X obj 77 691 t l l;
#X obj 37 638 t a a;
#X obj 349 681 s mtx_msg;
#X text 347 701 this is for debugging only;
#X text 699 620 this goes into [pd second_debounce];
#N canvas 402 218 593 435 buffers 0;
#X obj 37 24 r num_io;
#X obj 76 261 list;
#X obj 76 283 outlet;
#X obj 37 76 t l l b;
#X obj 215 25 loadbang;
#X obj 215 47 \$1;
#X obj 215 129 s matrix_ramp_time;
#X text 211 150 send the matrix ramp time to all [module_data] \, [input_state]
and [output_state] abstractions;
#X obj 215 69 sel 0;
#X msg 215 91 100;
#X obj 37 48 pack f f;
#X msg 249 247 clear;
#X obj 37 99 unpack;
#X obj 76 150 until;
#X obj 76 195 f;
#X obj 106 195 + 1;
#X msg 94 171 0;
#X obj 76 217 t f f;
#X obj 76 128 t f b f;
#X obj 146 234 t f f;
#X obj 179 257 * 30;
#X obj 179 279 + 20;
#X obj 146 309 pack;
#X obj 76 239 sel;
#X obj 145 145 - 1;
#N canvas 1 191 485 834 \$0-tables 0;
#X restore 146 391 pd \$0-tables;
#X obj 146 364 s pd-\$0-tables;
#X msg 146 339 obj 20 \$2 array define output\$1 64;
#X connect 0 0 10 0;
#X connect 1 0 2 0;
#X connect 3 0 12 0;
#X connect 3 1 1 1;
#X connect 3 2 11 0;
#X connect 4 0 5 0;
#X connect 5 0 8 0;
#X connect 8 0 9 0;
#X connect 8 1 6 0;
#X connect 9 0 6 0;
#X connect 10 0 3 0;
#X connect 11 0 26 0;
#X connect 12 1 18 0;
#X connect 13 0 14 0;
#X connect 14 0 15 0;
#X connect 14 0 17 0;
#X connect 15 0 14 1;
#X connect 16 0 14 1;
#X connect 17 0 23 0;
#X connect 17 1 19 0;
#X connect 18 0 13 0;
#X connect 18 1 16 0;
#X connect 18 2 24 0;
#X connect 19 0 22 0;
#X connect 19 1 20 0;
#X connect 20 0 21 0;
#X connect 21 0 22 1;
#X connect 22 0 27 0;
#X connect 23 0 1 0;
#X connect 24 0 23 1;
#X connect 27 0 26 0;
#X restore 745 594 pd buffers;
#X text 187 25 incoming bytes are input byte (split in two) \, number
of input pins of current module \, output pin number \, and total number
of input pins of previous modules;
#N canvas 1 82 450 300 send_connections 0;
#X obj 53 90 list split 1;
#X obj 68 250 s;
#X obj 68 180 list;
#X obj 53 204 t b f;
#X msg 86 228 symbol input\$1;
#X obj 53 66 inlet;
#X obj 53 112 - 1;
#X obj 93 112 unpack;
#X obj 93 134 - 1;
#X obj 93 156 pack;
#X text 11 15 I/O for this system is zero based while the [mtx] family
is 1 based so we need to do this simple conversion here;
#X connect 0 0 6 0;
#X connect 0 1 7 0;
#X connect 2 0 1 0;
#X connect 3 0 2 0;
#X connect 3 1 4 0;
#X connect 4 0 1 1;
#X connect 5 0 0 0;
#X connect 6 0 3 0;
#X connect 7 0 8 0;
#X connect 7 1 9 1;
#X connect 8 0 9 0;
#X connect 9 0 2 1;
#X restore 77 739 pd send_connections;
#X connect 0 0 12 0;
#X connect 1 0 6 0;
#X connect 1 0 2 0;
#X connect 2 0 17 0;
#X connect 3 0 9 0;
#X connect 4 0 3 1;
#X connect 5 0 1 1;
#X connect 6 0 1 1;
#X connect 8 0 0 0;
#X connect 9 0 8 0;
#X connect 9 1 5 0;
#X connect 9 2 2 1;
#X connect 9 3 15 0;
#X connect 10 0 42 1;
#X connect 10 1 31 1;
#X connect 11 0 16 0;
#X connect 12 0 1 0;
#X connect 12 1 13 0;
#X connect 13 0 14 0;
#X connect 13 0 11 0;
#X connect 14 0 13 1;
#X connect 15 0 13 1;
#X connect 16 0 21 1;
#X connect 16 1 31 0;
#X connect 17 0 19 0;
#X connect 18 0 20 1;
#X connect 19 0 20 0;
#X connect 19 1 18 0;
#X connect 20 0 41 0;
#X connect 21 0 42 0;
#X connect 22 0 23 0;
#X connect 23 0 35 0;
#X connect 24 0 36 0;
#X connect 25 0 53 0;
#X connect 26 0 18 1;
#X connect 26 1 27 0;
#X connect 27 0 28 0;
#X connect 28 0 53 0;
#X connect 30 0 25 1;
#X connect 30 1 35 0;
#X connect 31 0 22 0;
#X connect 32 0 47 0;
#X connect 35 0 26 0;
#X connect 36 0 45 0;
#X connect 40 0 46 0;
#X connect 40 1 35 0;
#X connect 41 0 40 0;
#X connect 41 1 21 0;
#X connect 42 0 40 1;
#X connect 45 0 35 0;
#X connect 45 1 44 0;
#X connect 46 0 52 0;
#X connect 47 0 3 0;
#X connect 47 1 4 0;
#X connect 47 2 8 1;
#X connect 47 3 10 0;
#X connect 47 4 11 1;
#X connect 49 1 51 0;
#X connect 51 0 58 0;
#X connect 51 1 48 0;
#X connect 52 0 49 0;
#X connect 52 1 25 0;
#X connect 56 0 36 0;
